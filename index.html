<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>AceTrace Tennis Tracker</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'media',
        theme: {
          extend: {
            colors: {
              p1: '#3b82f6',
              p2: '#ef4444',
              dark: '#0f172a',
              card: '#1e293b',
            },
            fontFamily: {
              mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", 'monospace'],
            },
            animation: {
              'spin-slow': 'spin 3s linear infinite',
            }
          }
        }
      }
    </script>

    <!-- Custom Styles -->
    <style>
      .no-scrollbar::-webkit-scrollbar { display: none; }
      .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
      body { overscroll-behavior: none; transition: background-color 0.3s, color 0.3s; }
      @media (prefers-color-scheme: dark) { body { background-color: #0f172a; color: white; } }
      @media (prefers-color-scheme: light) { body { background-color: #f8fafc; color: #0f172a; } }
    </style>

    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map: STRICTLY PINNED VERSIONS TO AVOID CONFLICTS -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.263.1?deps=react@18.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
  </head>
  <body>
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef } from 'react';
      import { createRoot } from 'react-dom/client';
      import { 
        Undo2, Settings, Trophy, RefreshCcw, RotateCcw, AlertTriangle, X, Save 
      } from 'lucide-react';

      // --- TYPES & CONSTANTS ---
      const PlayerId = {
        P1: 'P1',
        P2: 'P2',
      };

      const DEFAULT_CONFIG = {
        p1Name: "Player 1",
        p2Name: "Player 2",
        setsToWin: 2, // Best of 3
        useAdvantage: false, // Default to No-Ad
        finalSetType: 'superTieBreak', // Default to Super Tie Break
        tieBreakAt: 6,
        tieBreakPoints: 7,
      };

      const INITIAL_SETS_STATE = [
        { [PlayerId.P1]: 0, [PlayerId.P2]: 0 }
      ];

      // --- LOGIC ---
      const cloneState = (state) => JSON.parse(JSON.stringify(state));
      const getOtherPlayer = (id) => (id === PlayerId.P1 ? PlayerId.P2 : PlayerId.P1);

      const initializeMatch = (config) => ({
        config,
        startTime: Date.now(),
        durationSeconds: 0,
        isMatchOver: false,
        currentSetIndex: 0,
        sets: cloneState({ sets: INITIAL_SETS_STATE }).sets,
        games: { [PlayerId.P1]: 0, [PlayerId.P2]: 0 },
        points: { [PlayerId.P1]: "0", [PlayerId.P2]: "0" },
        isTieBreak: false,
        server: PlayerId.P1,
        isSecondServe: false,
        shouldSwitchSides: false,
        history: [],
      });

      const addPoint = (currentState, winner) => {
        if (currentState.isMatchOver) return currentState;

        let state = cloneState(currentState);
        const loser = getOtherPlayer(winner);
        
        let eventType = 'POINT';
        let gameWon = false;
        let setWon = false;
        let matchWon = false;
        
        const wasTieBreak = state.isTieBreak;

        // --- TIE BREAK SCENARIO ---
        if (state.isTieBreak) {
          const currentP1 = parseInt(state.points[PlayerId.P1]);
          const currentP2 = parseInt(state.points[PlayerId.P2]);
          
          if (winner === PlayerId.P1) state.points[PlayerId.P1] = currentP1 + 1;
          else state.points[PlayerId.P2] = currentP2 + 1;

          const newWinnerScore = state.points[winner];
          const newLoserScore = state.points[loser];
          
          let target = state.config.tieBreakPoints;
          
          // Check for Super Tie Break Set (Decider)
          const isDeciderSet = state.currentSetIndex === (state.config.setsToWin * 2 - 2);
          if (state.config.finalSetType === 'superTieBreak' && isDeciderSet) {
              target = 10;
          }

          if (newWinnerScore >= target && (newWinnerScore - newLoserScore) >= 2) {
            gameWon = true;
          }
        } 
        // --- STANDARD GAME SCENARIO ---
        else {
          const wScore = String(state.points[winner]);
          const lScore = String(state.points[loser]);

          if (wScore === "0") state.points[winner] = "15";
          else if (wScore === "15") state.points[winner] = "30";
          else if (wScore === "30") state.points[winner] = "40";
          else if (wScore === "40") {
            if (lScore === "40") {
              if (state.config.useAdvantage) {
                state.points[winner] = "Ad";
              } else {
                gameWon = true;
              }
            } else if (lScore === "Ad") {
              state.points[loser] = "40";
            } else {
              gameWon = true;
            }
          } else if (wScore === "Ad") {
            gameWon = true;
          }
        }

        // --- HANDLE GAME WIN ---
        if (gameWon) {
          eventType = 'GAME_WIN';
          state.games[winner]++;
          state.points = { [PlayerId.P1]: "0", [PlayerId.P2]: "0" };
          state.isTieBreak = false;

          if (wasTieBreak) {
              setWon = true;
          } else {
              const wGames = state.games[winner];
              const lGames = state.games[loser];
              const tbAt = state.config.tieBreakAt;

              if (wGames === tbAt && lGames === tbAt) {
                 state.isTieBreak = true;
                 state.points = { [PlayerId.P1]: 0, [PlayerId.P2]: 0 };
              } 
              else if (wGames === tbAt && lGames <= tbAt - 2) {
                 setWon = true;
              }
              else if (wGames === tbAt + 1 && lGames === tbAt - 1) {
                 setWon = true;
              }
          }
        }

        // --- HANDLE SET WIN ---
        if (setWon) {
          eventType = 'SET_WIN';
          state.sets[state.currentSetIndex] = { ...state.games };
          
          let p1Wins = 0;
          let p2Wins = 0;
          state.sets.forEach((s) => {
              if (s[PlayerId.P1] > s[PlayerId.P2]) p1Wins++;
              else if (s[PlayerId.P2] > s[PlayerId.P1]) p2Wins++;
          });

          if (p1Wins === state.config.setsToWin || p2Wins === state.config.setsToWin) {
            matchWon = true;
            eventType = 'MATCH_WIN';
            state.isMatchOver = true;
            state.winner = p1Wins > p2Wins ? PlayerId.P1 : PlayerId.P2;
          } else {
            state.currentSetIndex++;
            state.sets.push({ [PlayerId.P1]: 0, [PlayerId.P2]: 0 });
            state.games = { [PlayerId.P1]: 0, [PlayerId.P2]: 0 };
            
            if (state.config.finalSetType === 'superTieBreak' && 
                state.currentSetIndex === (state.config.setsToWin * 2 - 2)) {
                state.isTieBreak = true;
                state.points = { [PlayerId.P1]: 0, [PlayerId.P2]: 0 };
            }
          }
        }

        // --- HANDLE SIDE SWITCH LOGIC ---
        const isSetTransition = eventType === 'SET_WIN' && !matchWon;
        let switchSides = false;
        
        if (state.isTieBreak) {
           const pts = parseInt(state.points[PlayerId.P1]) + parseInt(state.points[PlayerId.P2]);
           if (pts > 0 && pts % 6 === 0) switchSides = true;
        } else {
           let totalGames = 0;
           if (isSetTransition) {
              const finishedSet = state.sets[state.currentSetIndex - 1];
              totalGames = finishedSet[PlayerId.P1] + finishedSet[PlayerId.P2];
           } else {
              totalGames = state.games[PlayerId.P1] + state.games[PlayerId.P2];
           }
           
           if (eventType === 'GAME_WIN' || isSetTransition) {
              if (totalGames % 2 !== 0) switchSides = true;
           }
        }

        state.shouldSwitchSides = switchSides;

        const event = {
          id: Date.now().toString() + Math.random().toString(),
          timestamp: Date.now(),
          type: eventType,
          winnerId: winner,
          scoreSnapshot: {
            sets: JSON.parse(JSON.stringify(state.sets)),
            games: { ...state.games },
            points: { ...state.points },
            isTieBreak: state.isTieBreak
          },
          sideSwitchAfter: switchSides
        };

        state.history.push(event);

        return state;
      };

      const undoPoint = (state) => {
        if (state.history.length === 0) return state;

        const newHistory = [...state.history];
        newHistory.pop();

        if (newHistory.length === 0) {
          const reset = initializeMatch(state.config);
          reset.startTime = state.startTime;
          return reset;
        }

        const lastEvent = newHistory[newHistory.length - 1];
        const snapshot = lastEvent.scoreSnapshot;

        return {
          ...state,
          history: newHistory,
          sets: JSON.parse(JSON.stringify(snapshot.sets)),
          games: { ...snapshot.games },
          points: { ...snapshot.points },
          isTieBreak: snapshot.isTieBreak,
          isMatchOver: false,
          winner: undefined,
          currentSetIndex: snapshot.sets.length - 1,
          shouldSwitchSides: lastEvent.sideSwitchAfter
        };
      };

      // --- COMPONENTS ---

      // MatchHistory Component
      const MatchHistory = ({ history, config, p1Color, p2Color }) => {
        const scrollRef = useRef(null);

        useEffect(() => {
          if (scrollRef.current) {
            scrollRef.current.scrollLeft = scrollRef.current.scrollWidth;
          }
        }, [history]);

        const rounds = [];
        let currentRoundPoints = [];
        let gameCounter = 0;
        let setCounter = 0;

        history.forEach((event) => {
          currentRoundPoints.push(event);
          if (event.type === 'GAME_WIN' || event.type === 'SET_WIN' || event.type === 'MATCH_WIN') {
              const p1G = event.scoreSnapshot.games[PlayerId.P1];
              const p2G = event.scoreSnapshot.games[PlayerId.P2];
              const isSetWin = event.type === 'SET_WIN' || event.type === 'MATCH_WIN';
              
              rounds.push({
                  gameIndex: gameCounter++,
                  winner: event.winnerId,
                  points: [...currentRoundPoints],
                  setIndex: setCounter,
                  gameScoreStr: `${p1G}-${p2G}`,
                  isSetEnd: isSetWin,
                  setWinner: isSetWin ? event.winnerId : undefined
              });
              currentRoundPoints = [];
              if (isSetWin) setCounter++;
          }
        });

        if (currentRoundPoints.length > 0) {
            const last = currentRoundPoints[currentRoundPoints.length - 1];
            const p1G = last.scoreSnapshot.games[PlayerId.P1];
            const p2G = last.scoreSnapshot.games[PlayerId.P2];
            rounds.push({
                gameIndex: gameCounter,
                winner: undefined,
                points: [...currentRoundPoints],
                setIndex: setCounter,
                gameScoreStr: `${p1G}-${p2G}`
            });
        }

        return (
          <div className="w-full bg-white dark:bg-slate-900 border-t border-slate-200 dark:border-slate-700 transition-colors duration-300">
            <div className="px-4 py-2 text-xs font-mono text-slate-500 dark:text-slate-400 uppercase tracking-widest border-b border-slate-100 dark:border-slate-800 flex justify-between">
              <span>Match Timeline</span>
              <span>{history.length} Events</span>
            </div>
            
            <div ref={scrollRef} className="flex overflow-x-auto p-4 items-center space-x-2 no-scrollbar h-48">
              {rounds.map((round, idx) => {
                const showSetDivider = idx > 0 && rounds[idx - 1].setIndex !== round.setIndex;
                const previousSetIndex = showSetDivider ? rounds[idx-1].setIndex : 0;
                
                return (
                <React.Fragment key={idx}>
                  {showSetDivider && (
                     <div className="flex flex-col justify-center items-center mx-4 h-32 relative group/divider">
                         <div className="h-full w-px bg-slate-300 dark:bg-slate-600"></div>
                         <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-slate-800 text-white dark:bg-slate-100 dark:text-slate-900 text-[10px] font-bold py-1 px-3 rounded-full border border-slate-600 dark:border-slate-300 whitespace-nowrap z-10 shadow-md">
                            SET {previousSetIndex + 1}
                         </div>
                     </div>
                  )}

                  <div className="flex flex-col min-w-[60px] relative group h-full justify-end pb-2">
                    {idx === 0 && (
                       <div className="absolute -top-6 left-0 text-[10px] font-bold text-slate-400 dark:text-slate-500 uppercase tracking-wider w-full text-center">
                          Set {round.setIndex + 1}
                       </div>
                    )}
                    <div className={`
                      flex flex-col items-center justify-between h-32 w-16 rounded-md border shadow-sm
                      ${round.winner === PlayerId.P1 
                          ? 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-500/30' 
                          : round.winner === PlayerId.P2 
                            ? 'bg-red-50 border-red-200 dark:bg-red-900/20 dark:border-red-500/30' 
                            : 'bg-slate-50 border-slate-200 dark:bg-slate-800 dark:border-slate-600'}
                      transition-all duration-300 relative overflow-hidden
                    `}>
                      <div className="mt-2 w-full flex justify-center">
                         {round.winner ? (
                             <Trophy size={14} className={round.winner === PlayerId.P1 ? 'text-blue-500 dark:text-blue-400' : 'text-red-500 dark:text-red-400'} />
                         ) : (
                             <div className="text-[10px] text-slate-400 dark:text-slate-500 font-mono font-bold">ACTIVE</div>
                         )}
                      </div>
                      <div className="flex flex-col-reverse gap-1 my-2 w-full px-2 items-center flex-1 justify-center">
                         {round.points.map((pt) => (
                             <div key={pt.id} className="relative w-full flex justify-center">
                                 <div 
                                    className={`w-2 h-2 rounded-full ${pt.winnerId === PlayerId.P1 
                                      ? 'bg-blue-500 shadow-[0_0_5px_rgba(59,130,246,0.6)]' 
                                      : 'bg-red-500 shadow-[0_0_5px_rgba(239,68,68,0.6)]'}`}
                                 />
                                 {pt.sideSwitchAfter && (
                                     <RefreshCcw size={8} className="absolute -right-1 text-yellow-500 top-0" />
                                 )}
                             </div>
                         ))}
                      </div>
                      <div className="mb-1 text-[10px] font-mono font-bold text-slate-600 dark:text-slate-300 bg-white/60 dark:bg-black/40 px-1.5 py-0.5 rounded">
                          {round.gameScoreStr}
                      </div>
                    </div>
                    <div className="text-center mt-2 h-1 w-full flex justify-center">
                         {round.winner === PlayerId.P1 && <div className="h-1 w-8 bg-blue-500 rounded-full opacity-50"></div>}
                         {round.winner === PlayerId.P2 && <div className="h-1 w-8 bg-red-500 rounded-full opacity-50"></div>}
                    </div>
                  </div>
                </React.Fragment>
                )
              })}
              <div className="min-w-[20px]"></div>
            </div>
          </div>
        );
      };

      // ScoreControls Component
      const ScoreControls = ({ state, onPoint, onUndo, onSettings, onReset }) => {
        const p1Name = state.config.p1Name;
        const p2Name = state.config.p2Name;
        const p1Point = state.points[PlayerId.P1];
        const p2Point = state.points[PlayerId.P2];
        const showSwitch = state.shouldSwitchSides;

        const getServeSide = () => {
          if (state.isMatchOver) return null;
          const val = (p) => {
            if (typeof p === 'number') return p;
            switch(p) {
              case '0': return 0;
              case '15': return 1;
              case '30': return 2;
              case '40': return 3;
              case 'Ad': return 4;
              default: return 0;
            }
          };
          const p1Val = val(state.points[PlayerId.P1]);
          const p2Val = val(state.points[PlayerId.P2]);
          const total = p1Val + p2Val;
          return total % 2 === 0 ? 'Right (Deuce)' : 'Left (Ad)';
        };

        const serveSide = getServeSide();

        return (
          <div className="flex-1 flex flex-col relative">
            <div className="flex justify-between items-center p-3 bg-white dark:bg-slate-900 border-b border-slate-100 dark:border-slate-800">
               <button onClick={onUndo} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500 dark:text-slate-400">
                   <Undo2 size={20} />
               </button>
               <div className="flex gap-2">
                  <button onClick={onReset} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500 dark:text-slate-400">
                      <RotateCcw size={20} />
                  </button>
                  <button onClick={onSettings} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500 dark:text-slate-400">
                      <Settings size={20} />
                  </button>
               </div>
            </div>

            <div className="bg-slate-50 dark:bg-slate-950 py-3 border-b border-slate-200 dark:border-slate-800 shadow-sm relative overflow-hidden">
                <div className="flex justify-center items-center gap-6 relative z-10">
                    {state.currentSetIndex > 0 && (
                        <div className="flex gap-4 text-slate-400 dark:text-slate-500 text-sm font-mono font-bold">
                           {state.sets.slice(0, state.currentSetIndex).map((s, idx) => (
                               <div key={idx} className="flex flex-col items-center">
                                   <span className="text-[10px] uppercase tracking-wider mb-0.5">Set {idx+1}</span>
                                   <span className={s[PlayerId.P1] > s[PlayerId.P2] ? 'text-blue-500' : 'text-red-500'}>
                                       {s[PlayerId.P1]}-{s[PlayerId.P2]}
                                   </span>
                               </div>
                           ))}
                        </div>
                    )}
                    <div className="flex flex-col items-center px-4 py-1 bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-slate-200 dark:border-slate-700">
                        <span className="text-[10px] font-bold text-slate-400 dark:text-slate-500 uppercase tracking-widest mb-1">
                            Set {state.currentSetIndex + 1}
                        </span>
                        <div className="text-3xl font-mono font-black tracking-widest leading-none flex gap-3 text-slate-900 dark:text-white">
                            <span className="text-blue-600 dark:text-blue-400">{state.games[PlayerId.P1]}</span>
                            <span className="text-slate-300 dark:text-slate-600">-</span>
                            <span className="text-red-600 dark:text-red-400">{state.games[PlayerId.P2]}</span>
                        </div>
                    </div>
                </div>
            </div>

            {showSwitch && !state.isMatchOver && (
                <div className="absolute top-[80px] left-0 right-0 z-30 flex justify-center pointer-events-none">
                    <div className="bg-yellow-400 dark:bg-yellow-500 text-black px-6 py-2 rounded-full font-black text-sm uppercase tracking-widest shadow-xl flex items-center gap-3 animate-bounce">
                        <RefreshCcw size={18} className="animate-spin-slow" />
                        <span>Switch Ends</span>
                        <RefreshCcw size={18} className="animate-spin-slow" />
                    </div>
                </div>
            )}

            {!state.isMatchOver && (
              <div className="flex justify-center mt-4">
                 <div className={`
                   backdrop-blur text-slate-600 dark:text-slate-300 px-4 py-1.5 rounded-full text-xs font-bold uppercase tracking-wider flex items-center gap-2 border transition-all duration-300
                   ${showSwitch 
                      ? 'bg-yellow-100 dark:bg-yellow-900/30 border-yellow-300 dark:border-yellow-700/50 opacity-50 scale-90' 
                      : 'bg-white/50 dark:bg-slate-800/50 border-slate-200 dark:border-slate-700'}
                 `}>
                    <span className="text-slate-400 dark:text-slate-500">Serve</span>
                    <span className="text-slate-900 dark:text-white flex items-center gap-1">
                       {serveSide === 'Right (Deuce)' ? 'Right' : 'Left'}
                       <span className="opacity-50 font-normal normal-case">
                         ({serveSide === 'Right (Deuce)' ? 'Deuce' : 'Ad'})
                       </span>
                    </span>
                 </div>
              </div>
            )}

            <div className="flex-1 flex flex-col justify-center gap-2 p-2 relative">
                <button 
                   onClick={() => onPoint(PlayerId.P1)}
                   disabled={state.isMatchOver}
                   className="group flex-1 bg-gradient-to-br from-blue-50 to-white dark:from-blue-900/40 dark:to-slate-900 border-l-4 border-blue-500 relative overflow-hidden rounded-xl active:scale-[0.98] transition-all touch-manipulation shadow-sm dark:shadow-none"
                >
                   <div className="absolute top-0 right-0 p-4 opacity-5 dark:opacity-10 group-hover:opacity-10 dark:group-hover:opacity-20 transition-opacity">
                       <div className="text-9xl font-black text-blue-500">P1</div>
                   </div>
                   <div className="flex items-center justify-between h-full px-6">
                       <div className="text-left z-10 flex flex-col items-start">
                           <div className="text-2xl font-bold text-slate-800 dark:text-blue-100 truncate max-w-[150px]">{p1Name}</div>
                           {state.server === PlayerId.P1 && !state.isMatchOver && (
                               <div className="mt-2 bg-blue-100 dark:bg-blue-500/20 text-blue-700 dark:text-blue-300 text-[10px] px-2 py-1 rounded-full inline-flex items-center gap-1 font-semibold">
                                  <span>SERVING</span>
                               </div>
                           )}
                       </div>
                       <div className="z-10 text-right">
                           <div className="text-7xl font-mono font-black text-slate-900 dark:text-white tracking-tighter shadow-blue-500 drop-shadow-lg">
                              {p1Point}
                           </div>
                       </div>
                   </div>
                </button>

                <div className="h-4 flex items-center justify-center">
                    {state.isTieBreak ? (
                        <span className="text-[10px] bg-purple-600 text-white px-3 py-0.5 rounded-full font-bold tracking-wider animate-pulse shadow-lg">TIE BREAK</span>
                    ) : (
                        <div className="w-full flex items-center gap-4 px-8 opacity-30">
                            <div className="h-[1px] bg-slate-300 dark:bg-slate-600 flex-1"></div>
                            <div className="h-[1px] bg-slate-300 dark:bg-slate-600 flex-1"></div>
                        </div>
                    )}
                </div>

                <button 
                   onClick={() => onPoint(PlayerId.P2)}
                   disabled={state.isMatchOver}
                   className="group flex-1 bg-gradient-to-br from-red-50 to-white dark:from-red-900/40 dark:to-slate-900 border-l-4 border-red-500 relative overflow-hidden rounded-xl active:scale-[0.98] transition-all touch-manipulation shadow-sm dark:shadow-none"
                >
                   <div className="absolute top-0 right-0 p-4 opacity-5 dark:opacity-10 group-hover:opacity-10 dark:group-hover:opacity-20 transition-opacity">
                       <div className="text-9xl font-black text-red-500">P2</div>
                   </div>
                   <div className="flex items-center justify-between h-full px-6">
                       <div className="text-left z-10 flex flex-col items-start">
                           <div className="text-2xl font-bold text-slate-800 dark:text-red-100 truncate max-w-[150px]">{p2Name}</div>
                           {state.server === PlayerId.P2 && !state.isMatchOver && (
                               <div className="mt-2 bg-red-100 dark:bg-red-500/20 text-red-700 dark:text-red-300 text-[10px] px-2 py-1 rounded-full inline-flex items-center gap-1 font-semibold">
                                  <span>SERVING</span>
                               </div>
                           )}
                       </div>
                       <div className="z-10 text-right">
                           <div className="text-7xl font-mono font-black text-slate-900 dark:text-white tracking-tighter drop-shadow-lg">
                              {p2Point}
                           </div>
                       </div>
                   </div>
                </button>
            </div>

            {state.isMatchOver && (
                <div className="absolute inset-0 bg-white/90 dark:bg-slate-900/90 backdrop-blur-md flex flex-col items-center justify-center z-50 animate-in fade-in duration-500">
                    <Trophy size={64} className="text-yellow-500 mb-4 animate-bounce" />
                    <h2 className="text-3xl font-bold text-slate-900 dark:text-white mb-2">MATCH OVER</h2>
                    <p className="text-xl text-slate-600 dark:text-slate-300 mb-8">
                        Winner: <span className={state.winner === PlayerId.P1 ? 'text-blue-600 dark:text-blue-400 font-bold' : 'text-red-600 dark:text-red-400 font-bold'}>
                            {state.winner === PlayerId.P1 ? p1Name : p2Name}
                        </span>
                    </p>
                    <div className="flex gap-4">
                        <button onClick={onUndo} className="px-6 py-2 rounded-full border border-slate-300 dark:border-slate-600 text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors">Undo Last Point</button>
                        <button onClick={onReset} className="px-6 py-2 rounded-full bg-slate-900 dark:bg-white text-white dark:text-slate-900 font-bold hover:opacity-90 transition-opacity">Start New Match</button>
                    </div>
                </div>
            )}
          </div>
        );
      };

      // SettingsModal Component
      const SettingsModal = ({ isOpen, onClose, config, onSave, onReset }) => {
        const [formData, setFormData] = useState(config);
        
        // Update local state when config prop changes
        useEffect(() => {
            setFormData(config);
        }, [config]);

        if (!isOpen) return null;

        const handleChange = (key, value) => {
          setFormData(prev => ({ ...prev, [key]: value }));
        };

        const handleSave = () => {
          onSave(formData);
          onClose();
        };

        return (
          <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/50 backdrop-blur-sm p-4 animate-in fade-in duration-200">
            <div className="bg-white dark:bg-slate-800 w-full max-w-md rounded-xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh] transition-colors duration-300">
              <div className="flex justify-between items-center p-4 border-b border-slate-200 dark:border-slate-700">
                <h3 className="text-lg font-bold text-slate-900 dark:text-white">Match Settings</h3>
                <button onClick={onClose} className="text-slate-500 hover:text-slate-900 dark:text-slate-400 dark:hover:text-white">
                  <X size={24} />
                </button>
              </div>

              <div className="overflow-y-auto p-4 space-y-6">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-xs font-bold text-blue-600 dark:text-blue-400 mb-1 uppercase">Player 1 Name</label>
                    <input type="text" value={formData.p1Name} onChange={(e) => handleChange('p1Name', e.target.value)}
                      className="w-full bg-slate-50 dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-slate-900 dark:text-white focus:border-blue-500 outline-none" />
                  </div>
                  <div>
                    <label className="block text-xs font-bold text-red-600 dark:text-red-400 mb-1 uppercase">Player 2 Name</label>
                    <input type="text" value={formData.p2Name} onChange={(e) => handleChange('p2Name', e.target.value)}
                      className="w-full bg-slate-50 dark:bg-slate-900 border border-slate-300 dark:border-slate-700 rounded p-2 text-slate-900 dark:text-white focus:border-red-500 outline-none" />
                  </div>
                </div>

                <div className="space-y-4">
                  <h4 className="text-xs font-bold text-slate-500 uppercase border-b border-slate-200 dark:border-slate-700 pb-1">Rules</h4>
                  <div className="flex items-center justify-between">
                    <span className="text-sm text-slate-700 dark:text-slate-300">Sets to Win</span>
                    <div className="flex bg-slate-100 dark:bg-slate-900 rounded p-1">
                      {[1, 2, 3].map(n => (
                        <button key={n} onClick={() => handleChange('setsToWin', n)}
                          className={`px-4 py-1 rounded text-sm transition-colors ${formData.setsToWin === n ? 'bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm' : 'text-slate-500'}`}>
                          {n}
                        </button>
                      ))}
                    </div>
                  </div>
                  <div className="flex items-center justify-between">
                    <span className="text-sm text-slate-700 dark:text-slate-300">Scoring Mode</span>
                    <div className="flex bg-slate-100 dark:bg-slate-900 rounded p-1">
                       <button onClick={() => handleChange('useAdvantage', true)} className={`px-3 py-1 rounded text-sm transition-colors ${formData.useAdvantage ? 'bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm' : 'text-slate-500'}`}>Advantage</button>
                       <button onClick={() => handleChange('useAdvantage', false)} className={`px-3 py-1 rounded text-sm transition-colors ${!formData.useAdvantage ? 'bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm' : 'text-slate-500'}`}>No Ad</button>
                    </div>
                  </div>
                  <div className="flex items-center justify-between">
                    <span className="text-sm text-slate-700 dark:text-slate-300">Final Set</span>
                    <div className="flex bg-slate-100 dark:bg-slate-900 rounded p-1">
                       <button onClick={() => handleChange('finalSetType', 'standard')} className={`px-3 py-1 rounded text-sm transition-colors ${formData.finalSetType === 'standard' ? 'bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm' : 'text-slate-500'}`}>Standard</button>
                       <button onClick={() => handleChange('finalSetType', 'superTieBreak')} className={`px-3 py-1 rounded text-sm transition-colors ${formData.finalSetType === 'superTieBreak' ? 'bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm' : 'text-slate-500'}`}>Super TB</button>
                    </div>
                  </div>
                  <div className="grid grid-cols-2 gap-4 pt-2">
                      <div>
                          <label className="block text-xs text-slate-500 mb-1">Tie-Break At (Games)</label>
                          <input type="number" min="1" max="20" value={formData.tieBreakAt} onChange={(e) => handleChange('tieBreakAt', parseInt(e.target.value) || 6)}
                              className="w-full bg-slate-100 dark:bg-slate-900 rounded p-2 text-center text-sm font-bold dark:text-white border border-slate-200 dark:border-slate-700" />
                      </div>
                      <div>
                          <label className="block text-xs text-slate-500 mb-1">TB Points to Win</label>
                          <input type="number" min="1" max="50" value={formData.tieBreakPoints} onChange={(e) => handleChange('tieBreakPoints', parseInt(e.target.value) || 7)}
                              className="w-full bg-slate-100 dark:bg-slate-900 rounded p-2 text-center text-sm font-bold dark:text-white border border-slate-200 dark:border-slate-700" />
                      </div>
                  </div>
                </div>
                
                <div className="pt-4 border-t border-slate-200 dark:border-slate-700">
                   <button onClick={() => { onClose(); onReset(); }}
                     className="w-full py-3 text-red-600 dark:text-red-500 border border-red-200 dark:border-red-900/50 hover:bg-red-50 dark:hover:bg-red-900/20 rounded font-bold transition-colors">
                       Reset Match
                   </button>
                </div>
              </div>

              <div className="p-4 bg-slate-50 dark:bg-slate-900 border-t border-slate-200 dark:border-slate-800">
                <button onClick={handleSave} className="w-full py-3 bg-blue-600 hover:bg-blue-500 text-white rounded font-bold flex items-center justify-center gap-2 shadow-lg shadow-blue-500/30">
                  <Save size={18} /> Apply Settings
                </button>
              </div>
            </div>
          </div>
        );
      };

      // App Component
      const App = () => {
        const [matchState, setMatchState] = useState(() => initializeMatch(DEFAULT_CONFIG));
        const [isSettingsOpen, setIsSettingsOpen] = useState(false);
        const [showResetConfirm, setShowResetConfirm] = useState(false);

        useEffect(() => {
          if (matchState.isMatchOver) return;
          const interval = setInterval(() => {
            setMatchState(prev => ({
              ...prev,
              durationSeconds: Math.floor((Date.now() - (prev.startTime || Date.now())) / 1000)
            }));
          }, 1000);
          return () => clearInterval(interval);
        }, [matchState.isMatchOver, matchState.startTime]);

        const handlePoint = (winner) => setMatchState(prev => addPoint(prev, winner));
        const handleUndo = () => setMatchState(prev => undoPoint(prev));
        const handleUpdateSettings = (newConfig) => setMatchState(prev => ({ ...prev, config: newConfig }));
        const handleReset = () => {
          setMatchState(initializeMatch(matchState.config));
          setShowResetConfirm(false);
        };

        const formatTime = (seconds) => {
          const h = Math.floor(seconds / 3600);
          const m = Math.floor((seconds % 3600) / 60);
          const s = seconds % 60;
          return `${h > 0 ? h + ':' : ''}${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        };

        return (
          <div className="h-screen w-full bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-white flex flex-col overflow-hidden transition-colors duration-300 relative">
            <div className="bg-white dark:bg-slate-900 border-b border-slate-200 dark:border-slate-800 p-2 text-center flex justify-center items-center gap-4 text-xs font-mono text-slate-500 dark:text-slate-400">
               <span>TIME: {formatTime(matchState.durationSeconds)}</span>
               <span className="w-1 h-1 bg-slate-400 dark:bg-slate-600 rounded-full"></span>
               <span>{matchState.config.useAdvantage ? 'ADVANTAGE' : 'NO-AD'}</span>
               <span className="w-1 h-1 bg-slate-400 dark:bg-slate-600 rounded-full"></span>
               <span>BEST OF {matchState.config.setsToWin === 1 ? '1' : matchState.config.setsToWin === 2 ? '3' : '5'}</span>
            </div>

            <ScoreControls 
              state={matchState} 
              onPoint={handlePoint} 
              onUndo={handleUndo} 
              onSettings={() => setIsSettingsOpen(true)}
              onReset={() => setShowResetConfirm(true)}
            />

            <div className="flex-shrink-0">
               <MatchHistory 
                  history={matchState.history} 
                  config={matchState.config}
                  p1Color="blue"
                  p2Color="red"
               />
            </div>

            <SettingsModal 
              isOpen={isSettingsOpen}
              onClose={() => setIsSettingsOpen(false)}
              config={matchState.config}
              onSave={handleUpdateSettings}
              onReset={() => setShowResetConfirm(true)} // Trigger modal directly from settings
            />

            {showResetConfirm && (
              <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                 <div className="bg-white dark:bg-slate-900 rounded-xl shadow-2xl p-6 max-w-sm w-full border border-slate-200 dark:border-slate-800">
                    <div className="flex flex-col items-center text-center">
                       <div className="w-12 h-12 bg-yellow-100 dark:bg-yellow-900/30 rounded-full flex items-center justify-center mb-4">
                          <AlertTriangle className="text-yellow-600 dark:text-yellow-500" size={24} />
                       </div>
                       <h3 className="text-lg font-bold text-slate-900 dark:text-white mb-2">Reset Match?</h3>
                       <p className="text-slate-500 dark:text-slate-400 text-sm mb-6">
                          This will clear all scores and history. You cannot undo this action.
                       </p>
                       <div className="flex w-full gap-3">
                          <button onClick={() => setShowResetConfirm(false)}
                            className="flex-1 py-2.5 rounded-lg border border-slate-200 dark:border-slate-700 font-semibold text-slate-600 dark:text-slate-300 hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors">
                            Cancel
                          </button>
                          <button onClick={handleReset}
                            className="flex-1 py-2.5 rounded-lg bg-red-600 text-white font-bold hover:bg-red-700 shadow-lg shadow-red-500/20 transition-colors">
                            Reset
                          </button>
                       </div>
                    </div>
                 </div>
              </div>
            )}
          </div>
        );
      };

      // --- MOUNT ---
      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>