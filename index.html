<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>AceTrace Tennis Tracker</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'media',
        theme: {
          extend: {
            colors: {
              dark: '#0f172a',
              card: '#1e293b',
            },
            fontFamily: {
              mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', "Liberation Mono", "Courier New", 'monospace'],
            },
            animation: {
              'spin-slow': 'spin 3s linear infinite',
            }
          }
        }
      }
    </script>

    <!-- Custom Styles -->
    <style>
      .no-scrollbar::-webkit-scrollbar { display: none; }
      .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
      body { overscroll-behavior: none; transition: background-color 0.3s, color 0.3s; }
      @media (prefers-color-scheme: dark) { body { background-color: #0f172a; color: white; } }
      @media (prefers-color-scheme: light) { body { background-color: #f8fafc; color: #0f172a; } }
      .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
    </style>

    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.263.1?deps=react@18.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
  </head>
  <body>
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef } from 'react';
      import { createRoot } from 'react-dom/client';
      import { 
        Undo2, Settings, Trophy, RefreshCcw, RotateCcw, AlertTriangle, X, Save, Circle, Clock, ChevronDown, Users, User, Maximize, Minimize
      } from 'lucide-react';

      // --- TYPES & CONSTANTS ---
      const PlayerId = {
        P1: 'P1',
        P2: 'P2',
      };

      const COLORS = {
        blue: { 
            name: 'Blue', 
            primary: 'bg-blue-600', 
            hover: 'hover:bg-blue-500', 
            gradient: 'from-blue-500 to-blue-600',
            cardGradient: 'from-blue-50 to-white dark:from-blue-900/20 dark:to-slate-900',
            text: 'text-blue-600', 
            border: 'border-blue-600',
            borderLight: 'border-blue-200',
            dot: 'bg-blue-500',
            light: 'bg-blue-50',
            darkBg: 'dark:bg-blue-900/40',
            shadow: 'shadow-blue-500/20'
        },
        red: { 
            name: 'Red', 
            primary: 'bg-red-600', 
            hover: 'hover:bg-red-500', 
            gradient: 'from-red-500 to-red-600',
            cardGradient: 'from-red-50 to-white dark:from-red-900/20 dark:to-slate-900',
            text: 'text-red-600', 
            border: 'border-red-600',
            borderLight: 'border-red-200',
            dot: 'bg-red-500',
            light: 'bg-red-50',
            darkBg: 'dark:bg-red-900/40',
            shadow: 'shadow-red-500/20'
        },
        green: { 
            name: 'Green', 
            primary: 'bg-emerald-600', 
            hover: 'hover:bg-emerald-500',
            gradient: 'from-emerald-500 to-emerald-600',
            cardGradient: 'from-emerald-50 to-white dark:from-emerald-900/20 dark:to-slate-900',
            text: 'text-emerald-600', 
            border: 'border-emerald-600',
            borderLight: 'border-emerald-200',
            dot: 'bg-emerald-500',
            light: 'bg-emerald-50',
            darkBg: 'dark:bg-emerald-900/40',
            shadow: 'shadow-emerald-500/20'
        },
        orange: { 
            name: 'Orange', 
            primary: 'bg-orange-600', 
            hover: 'hover:bg-orange-500',
            gradient: 'from-orange-500 to-orange-600',
            cardGradient: 'from-orange-50 to-white dark:from-orange-900/20 dark:to-slate-900',
            text: 'text-orange-600', 
            border: 'border-orange-600',
            borderLight: 'border-orange-200',
            dot: 'bg-orange-500',
            light: 'bg-orange-50',
            darkBg: 'dark:bg-orange-900/40',
            shadow: 'shadow-orange-500/20'
        },
        purple: { 
            name: 'Purple', 
            primary: 'bg-purple-600', 
            hover: 'hover:bg-purple-500',
            gradient: 'from-purple-500 to-purple-600',
            cardGradient: 'from-purple-50 to-white dark:from-purple-900/20 dark:to-slate-900',
            text: 'text-purple-600', 
            border: 'border-purple-600',
            borderLight: 'border-purple-200',
            dot: 'bg-purple-500',
            light: 'bg-purple-50',
            darkBg: 'dark:bg-purple-900/40',
            shadow: 'shadow-purple-500/20'
        },
        pink: { 
            name: 'Pink', 
            primary: 'bg-pink-600', 
            hover: 'hover:bg-pink-500',
            gradient: 'from-pink-500 to-pink-600',
            cardGradient: 'from-pink-50 to-white dark:from-pink-900/20 dark:to-slate-900',
            text: 'text-pink-600', 
            border: 'border-pink-600',
            borderLight: 'border-pink-200',
            dot: 'bg-pink-500',
            light: 'bg-pink-50',
            darkBg: 'dark:bg-pink-900/40',
            shadow: 'shadow-pink-500/20'
        },
      };

      const DEFAULT_CONFIG = {
        mode: 'singles', // 'singles' | 'doubles'
        p1Name: "Player 1",
        p1PartnerName: "Partner 1",
        p2Name: "Player 2",
        p2PartnerName: "Partner 2",
        p1Color: "blue",
        p2Color: "red",
        setsToWin: 2, // Best of 3
        useAdvantage: false, // Default to No-Ad
        finalSetType: 'superTieBreak', // Default to Super Tie Break
        tieBreakAt: 6,
        tieBreakPoints: 7,
      };

      const INITIAL_SETS_STATE = [
        { [PlayerId.P1]: 0, [PlayerId.P2]: 0 }
      ];

      // --- LOGIC ---
      const cloneState = (state) => JSON.parse(JSON.stringify(state));
      const getOtherPlayer = (id) => (id === PlayerId.P1 ? PlayerId.P2 : PlayerId.P1);

      const initializeMatch = (config) => ({
        config,
        startTime: Date.now(),
        durationSeconds: 0,
        isMatchOver: false,
        currentSetIndex: 0,
        sets: cloneState({ sets: INITIAL_SETS_STATE }).sets,
        games: { [PlayerId.P1]: 0, [PlayerId.P2]: 0 },
        points: { [PlayerId.P1]: "0", [PlayerId.P2]: "0" },
        isTieBreak: false,
        server: PlayerId.P1, // Team Server
        p1ServerIdx: 0, // 0 or 1 (Index of serving partner)
        p2ServerIdx: 0, // 0 or 1
        tieBreakStarter: null, 
        shouldSwitchSides: false,
        history: [],
      });

      const addPoint = (currentState, winner) => {
        if (currentState.isMatchOver) return currentState;

        let state = cloneState(currentState);
        const loser = getOtherPlayer(winner);
        
        let eventType = 'POINT';
        let gameWon = false;
        let setWon = false;
        let matchWon = false;
        
        const wasTieBreak = state.isTieBreak;

        // --- TIE BREAK SCENARIO ---
        if (state.isTieBreak) {
          const currentP1 = parseInt(state.points[PlayerId.P1]);
          const currentP2 = parseInt(state.points[PlayerId.P2]);
          
          if (winner === PlayerId.P1) state.points[PlayerId.P1] = currentP1 + 1;
          else state.points[PlayerId.P2] = currentP2 + 1;

          const newWinnerScore = state.points[winner];
          const newLoserScore = state.points[loser];
          
          // Server Rotation in Tie Break
          const totalPoints = state.points[PlayerId.P1] + state.points[PlayerId.P2];
          if (totalPoints % 2 !== 0) {
              state.server = getOtherPlayer(state.server);
          }
          
          let target = state.config.tieBreakPoints;
          const isDeciderSet = state.currentSetIndex === (state.config.setsToWin * 2 - 2);
          if (state.config.finalSetType === 'superTieBreak' && isDeciderSet) {
              target = 10;
          }

          if (newWinnerScore >= target && (newWinnerScore - newLoserScore) >= 2) {
            gameWon = true;
          }
        } 
        // --- STANDARD GAME SCENARIO ---
        else {
          const wScore = String(state.points[winner]);
          const lScore = String(state.points[loser]);

          if (wScore === "0") state.points[winner] = "15";
          else if (wScore === "15") state.points[winner] = "30";
          else if (wScore === "30") state.points[winner] = "40";
          else if (wScore === "40") {
            if (lScore === "40") {
              if (state.config.useAdvantage) {
                state.points[winner] = "Ad";
              } else {
                gameWon = true;
              }
            } else if (lScore === "Ad") {
              state.points[loser] = "40";
            } else {
              gameWon = true;
            }
          } else if (wScore === "Ad") {
            gameWon = true;
          }
        }

        // --- HANDLE GAME WIN ---
        if (gameWon) {
          eventType = 'GAME_WIN';
          state.games[winner]++;
          state.points = { [PlayerId.P1]: "0", [PlayerId.P2]: "0" };
          state.isTieBreak = false;

          if (wasTieBreak) {
              setWon = true;
              if (state.tieBreakStarter) {
                  state.server = getOtherPlayer(state.tieBreakStarter);
                  state.tieBreakStarter = null;
              }
          } else {
              // Standard Game Win
              
              // 1. Rotate Internal Server for the team that just finished serving
              if (state.server === PlayerId.P1) {
                  state.p1ServerIdx = 1 - state.p1ServerIdx;
              } else {
                  state.p2ServerIdx = 1 - state.p2ServerIdx;
              }

              // 2. Switch Team Server
              state.server = getOtherPlayer(state.server);

              const wGames = state.games[winner];
              const lGames = state.games[loser];
              const tbAt = state.config.tieBreakAt;

              if (wGames === tbAt && lGames === tbAt) {
                 state.isTieBreak = true;
                 state.points = { [PlayerId.P1]: 0, [PlayerId.P2]: 0 };
                 state.tieBreakStarter = state.server; 
              } 
              else if (wGames === tbAt && lGames <= tbAt - 2) {
                 setWon = true;
              }
              else if (wGames === tbAt + 1 && lGames === tbAt - 1) {
                 setWon = true;
              }
          }
        }

        // --- HANDLE SET WIN ---
        if (setWon) {
          eventType = 'SET_WIN';
          state.sets[state.currentSetIndex] = { ...state.games };
          
          let p1Wins = 0;
          let p2Wins = 0;
          state.sets.forEach((s) => {
              if (s[PlayerId.P1] > s[PlayerId.P2]) p1Wins++;
              else if (s[PlayerId.P2] > s[PlayerId.P1]) p2Wins++;
          });

          if (p1Wins === state.config.setsToWin || p2Wins === state.config.setsToWin) {
            matchWon = true;
            eventType = 'MATCH_WIN';
            state.isMatchOver = true;
            state.winner = p1Wins > p2Wins ? PlayerId.P1 : PlayerId.P2;
          } else {
            state.currentSetIndex++;
            state.sets.push({ [PlayerId.P1]: 0, [PlayerId.P2]: 0 });
            state.games = { [PlayerId.P1]: 0, [PlayerId.P2]: 0 };
            
            if (state.config.finalSetType === 'superTieBreak' && 
                state.currentSetIndex === (state.config.setsToWin * 2 - 2)) {
                state.isTieBreak = true;
                state.points = { [PlayerId.P1]: 0, [PlayerId.P2]: 0 };
                state.tieBreakStarter = state.server;
            }
          }
        }

        // --- HANDLE SIDE SWITCH LOGIC ---
        const isSetTransition = eventType === 'SET_WIN' && !matchWon;
        let switchSides = false;
        
        if (state.isTieBreak) {
           const pts = parseInt(state.points[PlayerId.P1]) + parseInt(state.points[PlayerId.P2]);
           if (pts > 0 && pts % 6 === 0) switchSides = true;
        } else {
           let totalGames = 0;
           if (isSetTransition) {
              const finishedSet = state.sets[state.currentSetIndex - 1];
              totalGames = finishedSet[PlayerId.P1] + finishedSet[PlayerId.P2];
           } else {
              totalGames = state.games[PlayerId.P1] + state.games[PlayerId.P2];
           }
           
           if (eventType === 'GAME_WIN' || isSetTransition) {
              if (totalGames % 2 !== 0) switchSides = true;
           }
        }

        state.shouldSwitchSides = switchSides;

        const event = {
          id: Date.now().toString() + Math.random().toString(),
          timestamp: Date.now(),
          type: eventType,
          winnerId: winner,
          scoreSnapshot: {
            sets: JSON.parse(JSON.stringify(state.sets)),
            games: { ...state.games },
            points: { ...state.points },
            isTieBreak: state.isTieBreak,
            server: state.server,
            p1ServerIdx: state.p1ServerIdx,
            p2ServerIdx: state.p2ServerIdx,
          },
          sideSwitchAfter: switchSides
        };

        state.history.push(event);

        return state;
      };

      const undoPoint = (state) => {
        if (state.history.length === 0) return state;

        const newHistory = [...state.history];
        newHistory.pop();

        if (newHistory.length === 0) {
          const reset = initializeMatch(state.config);
          reset.startTime = state.startTime;
          return reset;
        }

        const lastEvent = newHistory[newHistory.length - 1];
        const snapshot = lastEvent.scoreSnapshot;
        
        return {
          ...state,
          history: newHistory,
          sets: JSON.parse(JSON.stringify(snapshot.sets)),
          games: { ...snapshot.games },
          points: { ...snapshot.points },
          isTieBreak: snapshot.isTieBreak,
          isMatchOver: false,
          winner: undefined,
          currentSetIndex: snapshot.sets.length - 1,
          shouldSwitchSides: lastEvent.sideSwitchAfter,
          server: snapshot.server || state.server, // Fallback for old history
          p1ServerIdx: snapshot.p1ServerIdx !== undefined ? snapshot.p1ServerIdx : state.p1ServerIdx,
          p2ServerIdx: snapshot.p2ServerIdx !== undefined ? snapshot.p2ServerIdx : state.p2ServerIdx,
        };
      };

      const toggleServerIdx = (state, teamId) => {
          const newState = cloneState(state);
          if (teamId === PlayerId.P1) newState.p1ServerIdx = 1 - newState.p1ServerIdx;
          else newState.p2ServerIdx = 1 - newState.p2ServerIdx;
          return newState;
      }

      // --- COMPONENTS ---

      // MatchHistory Component (Unchanged mostly)
      const MatchHistory = ({ history, config, p1Color, p2Color }) => {
        const scrollRef = useRef(null);
        
        const p1C = COLORS[p1Color] || COLORS.blue;
        const p2C = COLORS[p2Color] || COLORS.red;

        useEffect(() => {
          if (scrollRef.current) {
            scrollRef.current.scrollLeft = scrollRef.current.scrollWidth;
          }
        }, [history]);

        const rounds = [];
        let currentRoundPoints = [];
        let gameCounter = 0;
        let setCounter = 0;

        history.forEach((event) => {
          currentRoundPoints.push(event);
          if (event.type === 'GAME_WIN' || event.type === 'SET_WIN' || event.type === 'MATCH_WIN') {
              const p1G = event.scoreSnapshot.games[PlayerId.P1];
              const p2G = event.scoreSnapshot.games[PlayerId.P2];
              const isSetWin = event.type === 'SET_WIN' || event.type === 'MATCH_WIN';
              
              rounds.push({
                  gameIndex: gameCounter++,
                  winner: event.winnerId,
                  points: [...currentRoundPoints],
                  setIndex: setCounter,
                  gameScoreStr: `${p1G}-${p2G}`,
                  isSetEnd: isSetWin,
                  setWinner: isSetWin ? event.winnerId : undefined
              });
              currentRoundPoints = [];
              if (isSetWin) setCounter++;
          }
        });

        if (currentRoundPoints.length > 0) {
            const last = currentRoundPoints[currentRoundPoints.length - 1];
            const p1G = last.scoreSnapshot.games[PlayerId.P1];
            const p2G = last.scoreSnapshot.games[PlayerId.P2];
            rounds.push({
                gameIndex: gameCounter,
                winner: undefined,
                points: [...currentRoundPoints],
                setIndex: setCounter,
                gameScoreStr: `${p1G}-${p2G}`
            });
        }

        return (
          <div className="w-full bg-white dark:bg-slate-900 border-t border-slate-200 dark:border-slate-800 transition-colors duration-300 pb-safe">
            <div className="flex overflow-x-auto px-2 py-1 items-end space-x-1 no-scrollbar min-h-[4.5rem]" ref={scrollRef}>
              {rounds.map((round, idx) => {
                const showSetDivider = idx > 0 && rounds[idx - 1].setIndex !== round.setIndex;
                const previousSetIndex = showSetDivider ? rounds[idx-1].setIndex : 0;
                
                return (
                <React.Fragment key={idx}>
                  {showSetDivider && (
                     <div className="flex flex-col justify-end items-center mx-1 h-14 relative group/divider pb-1">
                         <div className="h-full w-px bg-slate-300 dark:bg-slate-600"></div>
                         <div className="absolute top-0 bg-slate-800 text-white dark:bg-slate-200 dark:text-slate-900 text-[8px] font-bold py-0.5 px-1.5 rounded-sm whitespace-nowrap z-10 shadow-sm">
                            SET {previousSetIndex + 1}
                         </div>
                     </div>
                  )}

                  <div className="flex flex-col relative group justify-end pb-1 h-16">
                    {idx === 0 && (
                       <div className="absolute -top-3 left-0 text-[8px] font-bold text-slate-400 dark:text-slate-500 uppercase w-full text-center">
                          Set {round.setIndex + 1}
                       </div>
                    )}
                    <div className={`
                      flex flex-col items-center justify-between w-12 h-14 rounded border shadow-sm
                      ${round.winner === PlayerId.P1 
                          ? `${p1C.light} ${p1C.borderLight} dark:${p1C.darkBg}` 
                          : round.winner === PlayerId.P2 
                            ? `${p2C.light} ${p2C.borderLight} dark:${p2C.darkBg}` 
                            : 'bg-slate-50 border-slate-200 dark:bg-slate-800 dark:border-slate-600'}
                      transition-all duration-300 relative overflow-hidden
                    `}>
                      <div className="flex flex-wrap justify-center content-start gap-1 w-full p-1.5 flex-1 overflow-hidden">
                         {round.points.map((pt) => (
                             <div key={pt.id} className="relative">
                                 <div 
                                    className={`w-2 h-2 rounded-full ${pt.winnerId === PlayerId.P1 
                                      ? `${p1C.dot}` 
                                      : `${p2C.dot}`}
                                      ${pt.sideSwitchAfter ? 'ring-2 ring-yellow-400 ring-offset-1 dark:ring-offset-slate-800' : ''}
                                      transition-all
                                    `}
                                 />
                             </div>
                         ))}
                      </div>
                      <div className="flex items-center gap-0.5 justify-center w-full py-0.5 bg-white/50 dark:bg-black/20 border-t border-black/5 dark:border-white/5">
                          <div className="text-[10px] font-mono font-bold text-slate-900 dark:text-white leading-none">
                              {round.gameScoreStr}
                          </div>
                      </div>
                    </div>
                  </div>
                </React.Fragment>
                )
              })}
              <div className="min-w-[10px]"></div>
            </div>
          </div>
        );
      };

      // ScoreControls Component
      const ScoreControls = ({ state, onPoint, onUndo, onSettings, onReset, onToggleServer }) => {
        const isDoubles = state.config.mode === 'doubles';
        const p1Names = isDoubles ? [state.config.p1Name, state.config.p1PartnerName] : [state.config.p1Name];
        const p2Names = isDoubles ? [state.config.p2Name, state.config.p2PartnerName] : [state.config.p2Name];
        
        const p1Point = state.points[PlayerId.P1];
        const p2Point = state.points[PlayerId.P2];
        const showSwitch = state.shouldSwitchSides;
        
        const p1C = COLORS[state.config.p1Color] || COLORS.blue;
        const p2C = COLORS[state.config.p2Color] || COLORS.red;
        
        const [isFullscreen, setIsFullscreen] = useState(false);

        useEffect(() => {
           const handleChange = () => setIsFullscreen(!!document.fullscreenElement);
           document.addEventListener('fullscreenchange', handleChange);
           return () => document.removeEventListener('fullscreenchange', handleChange);
        }, []);

        const toggleFullscreen = () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(e => console.log(e));
          } else {
            if (document.exitFullscreen) document.exitFullscreen();
          }
        };

        const getServeSide = () => {
          if (state.isMatchOver) return null;
          const val = (p) => {
            if (typeof p === 'number') return p;
            switch(p) {
              case '0': return 0;
              case '15': return 1;
              case '30': return 2;
              case '40': return 3;
              case 'Ad': return 4;
              default: return 0;
            }
          };
          const p1Val = val(state.points[PlayerId.P1]);
          const p2Val = val(state.points[PlayerId.P2]);
          const total = p1Val + p2Val;
          return total % 2 === 0 ? 'Right (Deuce)' : 'Left (Ad)';
        };

        const serveSide = getServeSide();
        
        const formatTime = (seconds) => {
          const h = Math.floor(seconds / 3600);
          const m = Math.floor((seconds % 3600) / 60);
          const s = seconds % 60;
          return `${h > 0 ? h + ':' : ''}${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        };

        const renderServingIndicator = (teamId, nameIdx) => {
            if (state.isMatchOver) return null;
            if (state.server !== teamId) return null;
            
            // Check if this specific partner is serving
            const activeIdx = teamId === PlayerId.P1 ? state.p1ServerIdx : state.p2ServerIdx;
            
            // If singles, nameIdx is 0 and activeIdx is 0 (default).
            if (isDoubles && activeIdx !== nameIdx) return null;

            return (
                <div 
                   onClick={(e) => { e.stopPropagation(); onToggleServer(teamId); }}
                   className="mt-1 flex items-center gap-2 animate-in fade-in duration-300 cursor-pointer"
                >
                    <div className={`bg-white/90 dark:bg-black/30 text-${teamId === PlayerId.P1 ? p1C.name.toLowerCase() : p2C.name.toLowerCase()}-700 dark:text-white text-[10px] px-2 py-0.5 rounded-full font-black tracking-widest flex items-center gap-1 shadow-sm`}>
                        SERVING
                    </div>
                    <div className="relative">
                        <div className="w-2.5 h-2.5 bg-yellow-400 rounded-full animate-bounce shadow-lg shadow-yellow-400/50" />
                        <div className="absolute inset-0 bg-yellow-400 rounded-full animate-ping opacity-50" />
                    </div>
                </div>
            );
        };

        return (
          <div className="flex-1 flex flex-col relative h-full">
            {/* Header */}
            <div className="flex justify-between items-center px-4 py-3 bg-white dark:bg-slate-900 border-b border-slate-100 dark:border-slate-800 shadow-sm z-20">
               <div className="flex flex-col">
                  <div className="flex items-center gap-2 text-slate-900 dark:text-white font-mono font-bold text-xl leading-none">
                      <Clock size={16} className="text-slate-400" />
                      {formatTime(state.durationSeconds)}
                  </div>
                  <div className="flex gap-2 mt-1 text-[10px] font-bold uppercase tracking-wider text-slate-400 dark:text-slate-500">
                      <span>{isDoubles ? 'Doubles' : 'Singles'}</span>
                      <span className="text-slate-300">â€¢</span>
                      <span>{state.config.useAdvantage ? 'Advantage' : 'No-Ad'}</span>
                  </div>
               </div>

               <div className="flex items-center gap-1">
                  <button onClick={toggleFullscreen} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500 dark:text-slate-400 active:scale-90 transition-transform hidden sm:block">
                      {isFullscreen ? <Minimize size={20} /> : <Maximize size={20} />}
                  </button>
                  <button onClick={onUndo} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500 dark:text-slate-400 active:scale-90 transition-transform">
                      <Undo2 size={20} />
                  </button>
                  <button onClick={onReset} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500 dark:text-slate-400 active:scale-90 transition-transform">
                      <RotateCcw size={20} />
                  </button>
                  <button onClick={onSettings} className="p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500 dark:text-slate-400 active:scale-90 transition-transform">
                      <Settings size={20} />
                  </button>
               </div>
            </div>

            {/* Score Strip */}
            <div className="bg-slate-50 dark:bg-slate-950 py-2 border-b border-slate-200 dark:border-slate-800 relative">
                <div className="flex justify-center items-center gap-6 relative z-10">
                    {state.currentSetIndex > 0 && (
                        <div className="flex gap-4 text-slate-400 dark:text-slate-500 text-xs font-mono font-bold opacity-70">
                           {state.sets.slice(0, state.currentSetIndex).map((s, idx) => (
                               <div key={idx} className="flex flex-col items-center">
                                   <span className="text-[9px] uppercase tracking-wider mb-0.5">Set {idx+1}</span>
                                   <span className={s[PlayerId.P1] > s[PlayerId.P2] ? p1C.text : p2C.text}>
                                       {s[PlayerId.P1]}-{s[PlayerId.P2]}
                                   </span>
                               </div>
                           ))}
                        </div>
                    )}
                    <div className="flex flex-col items-center px-5 py-1 bg-white dark:bg-slate-800 rounded-lg shadow-sm border border-slate-200 dark:border-slate-700">
                        <span className="text-[9px] font-bold text-slate-400 dark:text-slate-500 uppercase tracking-widest mb-0.5">
                            Set {state.currentSetIndex + 1}
                        </span>
                        <div className="text-3xl font-mono font-black tracking-widest leading-none flex gap-3 text-slate-900 dark:text-white">
                            <span className={p1C.text}>{state.games[PlayerId.P1]}</span>
                            <span className="text-slate-300 dark:text-slate-600">-</span>
                            <span className={p2C.text}>{state.games[PlayerId.P2]}</span>
                        </div>
                    </div>
                </div>
            </div>

            {showSwitch && !state.isMatchOver && (
                <div className="absolute top-[140px] left-0 right-0 z-30 flex justify-center pointer-events-none">
                    <div className="bg-yellow-400 dark:bg-yellow-500 text-black px-6 py-2 rounded-full font-black text-sm uppercase tracking-widest shadow-xl flex items-center gap-3 animate-bounce">
                        <RefreshCcw size={18} className="animate-spin-slow" />
                        <span>Switch Ends</span>
                        <RefreshCcw size={18} className="animate-spin-slow" />
                    </div>
                </div>
            )}

            {!state.isMatchOver && (
              <div className="flex justify-center mt-2">
                 <div className={`
                   backdrop-blur text-slate-600 dark:text-slate-300 px-3 py-1 rounded-full text-[10px] font-bold uppercase tracking-wider flex items-center gap-2 border transition-all duration-300
                   ${showSwitch 
                      ? 'bg-yellow-100 dark:bg-yellow-900/30 border-yellow-300 dark:border-yellow-700/50 opacity-50 scale-90' 
                      : 'bg-white/50 dark:bg-slate-800/50 border-slate-200 dark:border-slate-700'}
                 `}>
                    <span className="text-slate-400 dark:text-slate-500">Serve</span>
                    <span className="text-slate-900 dark:text-white flex items-center gap-1">
                       {serveSide === 'Right (Deuce)' ? 'Right' : 'Left'}
                       <span className="opacity-50 font-normal normal-case">
                         ({serveSide === 'Right (Deuce)' ? 'Deuce' : 'Ad'})
                       </span>
                    </span>
                 </div>
              </div>
            )}

            {/* Players */}
            <div className="flex-1 flex flex-col justify-center gap-2 p-2 relative min-h-0">
                {/* Player 1 Button */}
                <button 
                   onClick={() => onPoint(PlayerId.P1)}
                   disabled={state.isMatchOver}
                   className={`
                     group flex-1 bg-gradient-to-br ${p1C.cardGradient} 
                     relative overflow-hidden rounded-xl active:scale-[0.98] transition-all touch-manipulation shadow-md border-l-4 ${p1C.border} flex flex-col justify-center
                   `}
                >
                   <div className="flex items-center justify-between w-full px-6">
                       <div className="text-left z-10 flex flex-col items-start gap-1 min-w-0 flex-1">
                           {p1Names.map((name, idx) => (
                               <div key={idx} className="flex flex-col items-start w-full">
                                  <div className={`font-black text-slate-800 dark:text-white tracking-tight drop-shadow-sm truncate w-full ${isDoubles ? 'text-2xl sm:text-4xl' : 'text-5xl sm:text-7xl'}`}>
                                      {name}
                                  </div>
                                  {renderServingIndicator(PlayerId.P1, idx)}
                               </div>
                           ))}
                       </div>
                       <div className="z-10 text-right pl-4">
                           <div className={`text-7xl sm:text-8xl font-mono font-black ${p1C.text} tracking-tighter drop-shadow-sm`}>
                              {p1Point}
                           </div>
                       </div>
                   </div>
                </button>

                {/* VS */}
                <div className="h-4 flex items-center justify-center shrink-0">
                    {state.isTieBreak ? (
                        <span className="text-[10px] bg-purple-600 text-white px-3 py-0.5 rounded-full font-bold tracking-wider animate-pulse shadow-lg">TIE BREAK</span>
                    ) : (
                        <div className="w-full flex items-center gap-4 px-8 opacity-30">
                            <div className="h-[1px] bg-slate-300 dark:bg-slate-600 flex-1"></div>
                            <div className="h-[1px] bg-slate-300 dark:bg-slate-600 flex-1"></div>
                        </div>
                    )}
                </div>

                {/* Player 2 Button */}
                <button 
                   onClick={() => onPoint(PlayerId.P2)}
                   disabled={state.isMatchOver}
                   className={`
                     group flex-1 bg-gradient-to-br ${p2C.cardGradient} 
                     relative overflow-hidden rounded-xl active:scale-[0.98] transition-all touch-manipulation shadow-md border-l-4 ${p2C.border} flex flex-col justify-center
                   `}
                >
                   <div className="flex items-center justify-between w-full px-6">
                       <div className="text-left z-10 flex flex-col items-start gap-1 min-w-0 flex-1">
                           {p2Names.map((name, idx) => (
                               <div key={idx} className="flex flex-col items-start w-full">
                                  <div className={`font-black text-slate-800 dark:text-white tracking-tight drop-shadow-sm truncate w-full ${isDoubles ? 'text-2xl sm:text-4xl' : 'text-5xl sm:text-7xl'}`}>
                                      {name}
                                  </div>
                                  {renderServingIndicator(PlayerId.P2, idx)}
                               </div>
                           ))}
                       </div>
                       <div className="z-10 text-right pl-4">
                           <div className={`text-7xl sm:text-8xl font-mono font-black ${p2C.text} tracking-tighter drop-shadow-sm`}>
                              {p2Point}
                           </div>
                       </div>
                   </div>
                </button>
            </div>

            {state.isMatchOver && (
                <div className="absolute inset-0 bg-white/90 dark:bg-slate-900/90 backdrop-blur-md flex flex-col items-center justify-center z-50 animate-in fade-in duration-500">
                    <Trophy size={64} className="text-yellow-500 mb-4 animate-bounce" />
                    <h2 className="text-3xl font-bold text-slate-900 dark:text-white mb-2">MATCH OVER</h2>
                    <p className="text-xl text-slate-600 dark:text-slate-300 mb-8">
                        Winner: <span className={state.winner === PlayerId.P1 ? `${p1C.text} font-bold` : `${p2C.text} font-bold`}>
                            {state.winner === PlayerId.P1 ? p1Names.join(" & ") : p2Names.join(" & ")}
                        </span>
                    </p>
                    <div className="flex gap-4">
                        <button onClick={onUndo} className="px-6 py-2 rounded-full border border-slate-300 dark:border-slate-600 text-slate-600 dark:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors">Undo Last Point</button>
                        <button onClick={onReset} className="px-6 py-2 rounded-full bg-slate-900 dark:bg-white text-white dark:text-slate-900 font-bold hover:opacity-90 transition-opacity">Start New Match</button>
                    </div>
                </div>
            )}
          </div>
        );
      };

      // Configuration Screen
      const SetupScreen = ({ config, onStart }) => {
          const [formData, setFormData] = useState(config);
          
          const handleChange = (key, value) => {
             setFormData(prev => ({ ...prev, [key]: value }));
          };
          
          const ColorPicker = ({ label, value, onChange }) => (
            <div className="mb-2">
                <label className="block text-xs font-bold text-slate-500 mb-2 uppercase">{label}</label>
                <div className="flex gap-2 flex-wrap">
                    {Object.entries(COLORS).map(([key, color]) => (
                        <button
                           key={key}
                           onClick={() => onChange(key)}
                           className={`w-8 h-8 rounded-full ${color.primary} transition-transform hover:scale-110 ${value === key ? 'ring-2 ring-offset-2 ring-slate-400 dark:ring-offset-slate-800 scale-110' : 'opacity-70 hover:opacity-100'}`}
                           aria-label={color.name}
                        />
                    ))}
                </div>
            </div>
          );

          return (
             <div className="h-full w-full bg-slate-50 dark:bg-slate-950 p-6 overflow-y-auto pb-safe">
                 <div className="max-w-md mx-auto space-y-8">
                     <div className="text-center space-y-2">
                         <div className="inline-flex items-center justify-center w-16 h-16 bg-slate-900 dark:bg-white rounded-2xl shadow-xl mb-4">
                            <Trophy size={32} className="text-white dark:text-slate-900" />
                         </div>
                         <h1 className="text-3xl font-black text-slate-900 dark:text-white tracking-tight">AceTrace</h1>
                         <p className="text-slate-500 dark:text-slate-400">Match Setup</p>
                     </div>

                     <div className="bg-white dark:bg-slate-900 p-6 rounded-2xl shadow-sm border border-slate-200 dark:border-slate-800 space-y-6">
                         
                         {/* Mode Selection */}
                         <div>
                            <label className="block text-xs font-bold text-slate-500 mb-3 uppercase">Match Type</label>
                            <div className="flex bg-slate-100 dark:bg-slate-800 p-1 rounded-lg">
                                <button 
                                   onClick={() => handleChange('mode', 'singles')}
                                   className={`flex-1 py-2 rounded-md text-sm font-bold transition-all flex items-center justify-center gap-2 ${formData.mode === 'singles' ? 'bg-white dark:bg-slate-700 shadow-sm text-slate-900 dark:text-white' : 'text-slate-500'}`}
                                >
                                   <User size={16} /> Singles
                                </button>
                                <button 
                                   onClick={() => handleChange('mode', 'doubles')}
                                   className={`flex-1 py-2 rounded-md text-sm font-bold transition-all flex items-center justify-center gap-2 ${formData.mode === 'doubles' ? 'bg-white dark:bg-slate-700 shadow-sm text-slate-900 dark:text-white' : 'text-slate-500'}`}
                                >
                                   <Users size={16} /> Doubles
                                </button>
                            </div>
                         </div>
                         
                         {/* Team 1 Config */}
                         <div>
                             <div className="flex items-center justify-between mb-2">
                                 <label className="text-xs font-bold text-blue-500 uppercase">Team 1 (Blue)</label>
                             </div>
                             <div className="space-y-2">
                                 <input 
                                     type="text" 
                                     placeholder="Player 1 Name"
                                     value={formData.p1Name} 
                                     onChange={(e) => handleChange('p1Name', e.target.value)}
                                     className="w-full bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-3 text-slate-900 dark:text-white focus:ring-2 focus:ring-blue-500 outline-none font-bold"
                                 />
                                 {formData.mode === 'doubles' && (
                                     <input 
                                         type="text" 
                                         placeholder="Partner Name"
                                         value={formData.p1PartnerName} 
                                         onChange={(e) => handleChange('p1PartnerName', e.target.value)}
                                         className="w-full bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-3 text-slate-900 dark:text-white focus:ring-2 focus:ring-blue-500 outline-none font-bold"
                                     />
                                 )}
                                 <div className="pt-2">
                                     <ColorPicker label="Team Color" value={formData.p1Color} onChange={(c) => handleChange('p1Color', c)} />
                                 </div>
                             </div>
                         </div>

                         {/* Team 2 Config */}
                         <div>
                             <div className="flex items-center justify-between mb-2">
                                 <label className="text-xs font-bold text-red-500 uppercase">Team 2 (Red)</label>
                             </div>
                             <div className="space-y-2">
                                 <input 
                                     type="text" 
                                     placeholder="Player 2 Name"
                                     value={formData.p2Name} 
                                     onChange={(e) => handleChange('p2Name', e.target.value)}
                                     className="w-full bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-3 text-slate-900 dark:text-white focus:ring-2 focus:ring-red-500 outline-none font-bold"
                                 />
                                 {formData.mode === 'doubles' && (
                                     <input 
                                         type="text" 
                                         placeholder="Partner Name"
                                         value={formData.p2PartnerName} 
                                         onChange={(e) => handleChange('p2PartnerName', e.target.value)}
                                         className="w-full bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-3 text-slate-900 dark:text-white focus:ring-2 focus:ring-red-500 outline-none font-bold"
                                     />
                                 )}
                                 <div className="pt-2">
                                     <ColorPicker label="Team Color" value={formData.p2Color} onChange={(c) => handleChange('p2Color', c)} />
                                 </div>
                             </div>
                         </div>

                         {/* Quick Rules */}
                         <div className="space-y-4 pt-4 border-t border-slate-100 dark:border-slate-800">
                             <div className="flex items-center justify-between">
                                <span className="text-sm font-semibold text-slate-700 dark:text-slate-300">Sets</span>
                                <div className="flex bg-slate-100 dark:bg-slate-800 rounded p-1">
                                  {[1, 2, 3].map(n => (
                                    <button key={n} onClick={() => handleChange('setsToWin', n)}
                                      className={`px-3 py-1 rounded text-sm font-bold transition-colors ${formData.setsToWin === n ? 'bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm' : 'text-slate-500'}`}>
                                      {n}
                                    </button>
                                  ))}
                                </div>
                             </div>
                             <div className="flex items-center justify-between">
                                <span className="text-sm font-semibold text-slate-700 dark:text-slate-300">Scoring</span>
                                <div className="flex bg-slate-100 dark:bg-slate-800 rounded p-1">
                                   <button onClick={() => handleChange('useAdvantage', true)} className={`px-3 py-1 rounded text-sm font-bold transition-colors ${formData.useAdvantage ? 'bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm' : 'text-slate-500'}`}>Ad</button>
                                   <button onClick={() => handleChange('useAdvantage', false)} className={`px-3 py-1 rounded text-sm font-bold transition-colors ${!formData.useAdvantage ? 'bg-white dark:bg-slate-700 text-slate-900 dark:text-white shadow-sm' : 'text-slate-500'}`}>No-Ad</button>
                                </div>
                             </div>
                         </div>
                     </div>

                     <button 
                        onClick={() => onStart(formData)}
                        className="w-full py-4 bg-slate-900 dark:bg-white text-white dark:text-slate-900 rounded-xl font-black text-lg shadow-xl shadow-slate-900/20 active:scale-95 transition-all flex items-center justify-center gap-2"
                     >
                        START MATCH
                     </button>
                 </div>
             </div>
          );
      }

      // SettingsModal Component (Simplified to use same form structure logic if needed, but mostly reusing Setup for now or kept simple)
      const SettingsModal = ({ isOpen, onClose, config, onSave, onReset }) => {
        const [formData, setFormData] = useState(config);
        
        useEffect(() => { setFormData(config); }, [config]);
        if (!isOpen) return null;

        const handleChange = (key, value) => setFormData(prev => ({ ...prev, [key]: value }));

        return (
          <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-black/50 backdrop-blur-sm p-4 animate-in fade-in duration-200">
            <div className="bg-white dark:bg-slate-800 w-full max-w-md rounded-xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh] animate-in zoom-in-95 duration-200">
              <div className="flex justify-between items-center p-4 border-b border-slate-200 dark:border-slate-700">
                <h3 className="text-lg font-bold text-slate-900 dark:text-white">Match Settings</h3>
                <button onClick={onClose}><X size={24} className="text-slate-500" /></button>
              </div>
              <div className="p-4 space-y-4 overflow-y-auto">
                  {/* Simplified settings view for in-match changes */}
                   <div className="space-y-4">
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-slate-700 dark:text-slate-300">Sets to Win</span>
                        <div className="flex bg-slate-100 dark:bg-slate-900 rounded p-1">
                          {[1, 2, 3].map(n => (
                            <button key={n} onClick={() => handleChange('setsToWin', n)}
                              className={`px-4 py-1 rounded text-sm ${formData.setsToWin === n ? 'bg-white dark:bg-slate-700 shadow-sm font-bold' : 'text-slate-500'}`}>{n}</button>
                          ))}
                        </div>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-slate-700 dark:text-slate-300">Scoring</span>
                        <div className="flex bg-slate-100 dark:bg-slate-900 rounded p-1">
                           <button onClick={() => handleChange('useAdvantage', true)} className={`px-3 py-1 rounded text-sm ${formData.useAdvantage ? 'bg-white shadow-sm font-bold' : 'text-slate-500'}`}>Ad</button>
                           <button onClick={() => handleChange('useAdvantage', false)} className={`px-3 py-1 rounded text-sm ${!formData.useAdvantage ? 'bg-white shadow-sm font-bold' : 'text-slate-500'}`}>No Ad</button>
                        </div>
                      </div>
                      <div className="pt-2">
                        <label className="text-xs font-bold text-slate-500 uppercase">Tie Break At</label>
                        <input type="number" value={formData.tieBreakAt} onChange={(e) => handleChange('tieBreakAt', parseInt(e.target.value))} className="mt-1 w-full bg-slate-100 dark:bg-slate-900 p-2 rounded font-bold text-center" />
                      </div>
                   </div>
                   <div className="pt-4 border-t border-slate-200 dark:border-slate-700">
                      <button onClick={() => { onClose(); onReset(); }} className="w-full py-3 text-red-600 border border-red-200 rounded font-bold">Restart / New Match</button>
                   </div>
              </div>
              <div className="p-4 border-t border-slate-200 dark:border-slate-800 bg-slate-50 dark:bg-slate-900">
                <button onClick={() => { onSave(formData); onClose(); }} className="w-full py-3 bg-blue-600 text-white rounded font-bold shadow-lg">Save Changes</button>
              </div>
            </div>
          </div>
        );
      };

      // App Component
      const App = () => {
        const STORAGE_KEY = 'acetrace_match_state_v2';

        const [view, setView] = useState('loading'); // loading, setup, match
        const [matchState, setMatchState] = useState(null);
        
        const [isSettingsOpen, setIsSettingsOpen] = useState(false);
        const [showResetConfirm, setShowResetConfirm] = useState(false);

        // Initial Load
        useEffect(() => {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Check if match is ongoing
                    if (!parsed.isMatchOver) {
                        setMatchState(parsed);
                        setView('match');
                    } else {
                        // Match over, maybe show history or just setup
                        setMatchState(parsed); // Keep state just in case
                        setView('setup'); 
                    }
                } else {
                    setView('setup');
                    setMatchState(initializeMatch(DEFAULT_CONFIG));
                }
            } catch (e) {
                console.error(e);
                setView('setup');
                setMatchState(initializeMatch(DEFAULT_CONFIG));
            }
        }, []);

        // Persist state
        useEffect(() => {
            if (matchState) {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(matchState));
            }
        }, [matchState]);

        useEffect(() => {
          if (!matchState || matchState.isMatchOver || view !== 'match') return;
          const interval = setInterval(() => {
            setMatchState(prev => ({
              ...prev,
              durationSeconds: Math.floor((Date.now() - (prev.startTime || Date.now())) / 1000)
            }));
          }, 1000);
          return () => clearInterval(interval);
        }, [matchState?.isMatchOver, matchState?.startTime, view]);

        const handleStartMatch = (config) => {
            setMatchState(initializeMatch(config));
            setView('match');
        };

        const handlePoint = (winner) => setMatchState(prev => addPoint(prev, winner));
        const handleUndo = () => setMatchState(prev => undoPoint(prev));
        const handleUpdateSettings = (newConfig) => setMatchState(prev => ({ ...prev, config: newConfig }));
        const handleToggleServer = (teamId) => setMatchState(prev => toggleServerIdx(prev, teamId));

        const handleReset = () => {
           // Go back to setup for a "Hard Reset"
           setView('setup');
           setShowResetConfirm(false);
        };

        if (view === 'loading') return <div className="h-screen w-full bg-slate-50 flex items-center justify-center"><div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div></div>;

        if (view === 'setup') {
            return <SetupScreen config={matchState?.config || DEFAULT_CONFIG} onStart={handleStartMatch} />;
        }

        return (
          <div className="h-screen w-full bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-white flex flex-col overflow-hidden transition-colors duration-300 relative">
            
            <ScoreControls 
              state={matchState} 
              onPoint={handlePoint} 
              onUndo={handleUndo} 
              onSettings={() => setIsSettingsOpen(true)}
              onReset={() => setShowResetConfirm(true)}
              onToggleServer={handleToggleServer}
            />

            <div className="flex-shrink-0">
               <MatchHistory 
                  history={matchState.history} 
                  config={matchState.config}
                  p1Color={matchState.config.p1Color}
                  p2Color={matchState.config.p2Color}
               />
            </div>

            <SettingsModal 
              isOpen={isSettingsOpen}
              onClose={() => setIsSettingsOpen(false)}
              config={matchState.config}
              onSave={handleUpdateSettings}
              onReset={() => setShowResetConfirm(true)}
            />

            {showResetConfirm && (
              <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                 <div className="bg-white dark:bg-slate-900 rounded-xl shadow-2xl p-6 max-w-sm w-full border border-slate-200 dark:border-slate-800">
                    <div className="flex flex-col items-center text-center">
                       <div className="w-12 h-12 bg-yellow-100 dark:bg-yellow-900/30 rounded-full flex items-center justify-center mb-4">
                          <AlertTriangle className="text-yellow-600 dark:text-yellow-500" size={24} />
                       </div>
                       <h3 className="text-lg font-bold text-slate-900 dark:text-white mb-2">End Match?</h3>
                       <p className="text-slate-500 dark:text-slate-400 text-sm mb-6">
                          This will end the current match and return to the setup screen.
                       </p>
                       <div className="flex w-full gap-3">
                          <button onClick={() => setShowResetConfirm(false)}
                            className="flex-1 py-2.5 rounded-lg border border-slate-200 dark:border-slate-700 font-semibold text-slate-600 dark:text-slate-300 hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors">
                            Cancel
                          </button>
                          <button onClick={handleReset}
                            className="flex-1 py-2.5 rounded-lg bg-red-600 text-white font-bold hover:bg-red-700 shadow-lg shadow-red-500/20 transition-colors">
                            End Match
                          </button>
                       </div>
                    </div>
                 </div>
              </div>
            )}
          </div>
        );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>